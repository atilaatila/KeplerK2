#https://github.com/barentsen
#https://github.com/barentsen/k2mosaic
#https://github.com/KeplerGO/k2flix
#https://keplergo.github.io/KeplerScienceWebsite/software.html
#
#import galsim
import astropy
from astropy.io import fits
from astropy.wcs import WCS
from astropy.table import QTable, Table, Column
from PIL import Image
from astropy import units as u
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np
import pandas as pd
import seaborn as sns


from astropy import units as u
from astropy.coordinates import SkyCoord
#initializing skycoord(to use RA and DEC positioning)
Coord = SkyCoord(ra=10.625*u.degree, dec=41.2*u.degree, frame='icrs')
#URL of the fits files
base_url = "https://archive.stsci.edu/missions/k2/lightcurves/c3/200000000/04000/ktwo20000{4468:4684}-c03_llc.fits"

#initializing data holder
data = []

#Opening one fits file and checking contents to be able to understand the parameters
fits_file = ("https://archive.stsci.edu/missions/k2/lightcurves/c3/200000000/04000/ktwo200004469-c03_llc.fits")
    #fits.info(fits_file) #(these print the data)
    #fits.getdata(fits_file, ext=1).columns #(these print the data)
with fits.open(fits_file) as hdulist: 
    header1 = hdulist[1].header
    header2 = hdulist[2].header
with fits.open(fits_file) as hdulist:
    print("HEADER 1")
    print(repr(header1[0:20000])) #repr() prints the info into neat columns
    print("HEADER 2")
    print(repr(header2[0:20000])) #repr() prints the info into neat columns
    print(fits.getdata(fits_file).columns)



#creating grid for the pixels and populating it with zeroes ( two 454x118 are the dimentions perfectly fit for the data, 1280x1024 was for testing)
PixelGrid = np.zeros((454,118), dtype=object)
#PixelGrid = np.zeros((1280,1024), dtype=object)
PixelGrid2 = np.zeros((1280,1024), dtype=object)

Xval = []
Yval = []
Zval = []


#creating variable for me to be able to download all my fits files they go from ktwo200004469 to ktwo200004923
x = 4469
#loop for me to read and retrieve information from each file
while x < 4923:
    fits_file = ("https://archive.stsci.edu/missions/k2/lightcurves/c3/200000000/04000/ktwo20000%d-c03_llc.fits" % x)
    with fits.open(fits_file) as hdulist: 
        header1 = hdulist[1].header
        header2 = hdulist[2].header
        w = WCS(header2)
    with fits.open(fits_file, mode="readonly") as hdulist: 
        #inserting data from each fits file into a variable
        tess_bjds = hdulist[1].data['TIME']
        sap_fluxes = hdulist[1].data['SAP_FLUX']
        pdcsap_fluxes = hdulist[1].data['PDCSAP_FLUX']
        RA = header2['Ra_OBJ']
        DEC = header2['DEC_OBJ']
        PosX = header2['CRVAL1P']
        PosY = header2['CRVAL2P']


        # These values allow translation from RA,DEC to X,Y and vice versa. (new)
        crpix1 = header2['CRPIX1'] - 1 # X of reference pixel #dont know yet why -1
        crpix2 = header2['CRPIX2'] - 1 # Y of reference pixel #dont know yet why -1
        crval1 = header2['CRVAL1'] # RA of reference pixel
        crval2 = header2['CRVAL2'] # DEC of reference pixel
        cdelt1 = header2['CDELT1'] # [deg] pixel scale in RA dimension # using [deg] maybe needs to be SS arcsec per pixel
        cdelt2 = header2['CDELT2'] # [deg] pixel scale in Dec dimension
        cd1_1 = cdelt1 * header2['PC1_1'] # RA deg per column pixel
        cd1_2 = cdelt1 * header2['PC1_2'] # RA deg per row pixel
        cd2_1 = cdelt2 * header2['PC2_1'] # DEC deg per column pixel
        cd2_2 = cdelt2 *header2['PC2_2'] # DEC deg per row pixel

        PixelX, PixelY = w.wcs_world2pix(header2['DEC_OBJ'],header2['Ra_OBJ'], 0)
    # Getting Coordinates from Dec/Asc into cartesian if needed
    Coord = SkyCoord((header2['Ra_OBJ'])*u.degree,(header2['DEC_OBJ'])*u.degree) 


    # Find the X,Y values of the galaxy's RA and DEC.
    det = cd1_1 * cd2_2 - cd1_2 * cd2_1

    cdinv11 = cd2_2 / det
    cdinv12 = -cd1_2 / det
    cdinv21 = -cd2_1 / det
    cdinv22 = cd1_1 / det

    ra0 = crval1 / 180.0 * np.pi
    dec0 = crval2 / 180.0 * np.pi
    ra = RA / 180.0 * np.pi
    dec = DEC / 180.0 * np.pi

    bottom = np.sin(dec)*np.sin(dec0) + np.cos(dec)*np.cos(dec0)*np.cos(ra-ra0)

    xi = np.cos(dec) * np.sin(ra-ra0) / bottom
    eta = (np.sin(dec)*np.cos(dec0) - np.cos(dec)*np.sin(dec0)*np.cos(ra-ra0)) / bottom
    xi = xi * 180.0 / np.pi
    eta = eta * 180.0 / np.pi

    galaxy_X = cdinv11 * xi + cdinv12 * eta + crpix1
    galaxy_Y = cdinv21 * xi + cdinv22 * eta + crpix2

    #galaxy_X, galaxy_Y
    Xval.append(galaxy_X)
    Yval.append(galaxy_Y)

    # creating a table with all the information that I gathered from the fits file into the data holder i created earlier, 
    #append will insert new rows into the data table with respective information
    #sap_fluxes[0] and tess_bjds[0] are the first instances(at time = 0) of flux and time, using until i find a way of getting the flux of all the time
    data.append([x,RA,DEC,PosX,PosY,sap_fluxes[2000],tess_bjds[0],PixelX,PixelY]) 

    #Xval.append(RA)
    #Yval.append(DEC)

    Zval.append(sap_fluxes[2000])
    #calculating realposX and realposY so i can create a appropriate sized grid since 
    #CCD positions go from Y 699 to 816(so i remove 699 to start and 0) same for posX(goes from 548 to 95)
    realPosX = (PosX-95)
    realPosY = (PosY-699)
    #realPosX = PosX #(test with 1280,1024 grid)
    PixelGrid[realPosX, realPosY] = sap_fluxes[2000] # inserting flux from time=0 (later make into all fluxes) into each respective X,Y positions
    #w = WCS(hdulist[1].header)
    


    x += 1 #for my while loop

#printing File number, RA, DEC, CCD X, CCD Y, flux, timestamp    
pixelDatatable = pd.DataFrame(data)
print (pixelDatatable)


# read in the array of cadence quality flags
with fits.open(fits_file, mode="readonly") as hdulist:
    qual_flags = hdulist[1].data['SAP_QUALITY']
# Start figure and axis.
fig, ax = plt.subplots()
# Plot the timeseries in black circles.
ax.plot(tess_bjds, pdcsap_fluxes, 'ko')
# Locate quality flags greater than zero.
where_gt0 = np.where(qual_flags > 0)[0]

'''# Overplot the fluxes with quality flags greater than zero in red.
ax.plot(tess_bjds[where_gt0], pdcsap_fluxes[where_gt0], 'ro')

fig.suptitle("Light Curve")
ax.set_ylabel("PDCSAP Flux (e-/s)")
ax.set_xlabel("Time (TBJD)")
plt.show()
'''

print('The matrix is : \n', PixelGrid) 
#imagePixelGrid = np.reshape(, (118,454))
imagePixelGrid = np.reshape(PixelGrid, (454,118))#not sure why i need to do this but i cant work with the grid unless i reshape it
#imagePixelGrid = PixelGrid#testing without reshaping

#creating image and saving image, astype() is used since the grid was an OBJECT grid and needed to be converted
ImageObj = Image.fromarray((PixelGrid).astype(np.uint8))
ImageObj.save('PixelGridTest.png')

#testing the pixel image show(not working)
im=plt.imshow(PixelGrid.astype(float), interpolation='nearest', cmap=cm.Greys_r)
plt.show()


x = Xval
y = Yval
z = Zval
data2 = pd.DataFrame(data={'x':x, 'y':y, 'z':z})
data2 = data2.pivot(index='x', columns='y', values='z')
sns.heatmap(data2, cmap='gray')
plt.show()


"""shape = np.unique(x).shape[0],np.unique(y).shape[0]
x_arr = x.reshape(shape)
y_arr = y.reshape(shape)
z_arr = z.reshape(shape)
plt.pcolormesh(x_arr,y_arr,z_arr)"""



#saving data into excel for further analysis
df = pd.DataFrame(PixelGrid).T
df.to_excel(excel_writer = "D:/Kepler Code/KeplerK2/gridexcel.xlsx")
df = pd.DataFrame(pixelDatatable).T
df.to_excel(excel_writer = "D:/Kepler Code/KeplerK2/gridexcelComplete.xlsx")