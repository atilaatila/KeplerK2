#https://github.com/barentsen
#https://github.com/barentsen/k2mosaic
#https://github.com/KeplerGO/k2flix
#https://keplergo.github.io/KeplerScienceWebsite/software.html
#
#import galsim
import astropy
from astropy.io import fits
from astropy.wcs import WCS
from astropy.table import QTable, Table, Column
from PIL import Image
from astropy import units as u
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np
import pandas as pd
from astropy.wcs import WCS

from astropy import units as u
from astropy.coordinates import SkyCoord
#initializing skycoord(to use RA and DEC positioning)
Coord = SkyCoord(ra=10.625*u.degree, dec=41.2*u.degree, frame='icrs')
#URL of the fits files
base_url = "https://archive.stsci.edu/missions/k2/lightcurves/c3/200000000/04000/ktwo20000{4468:4684}-c03_llc.fits"

#initializing data holder
data = []

#Opening one fits file and checking contents to be able to understand the parameters
fits_file = ("https://archive.stsci.edu/missions/k2/lightcurves/c3/200000000/04000/ktwo200004469-c03_llc.fits")
    #fits.info(fits_file) #(these print the data)
    #fits.getdata(fits_file, ext=1).columns #(these print the data)
with fits.open(fits_file) as hdulist: 
    header1 = hdulist[1].header
    header2 = hdulist[2].header
with fits.open(fits_file) as hdulist:
    print("HEADER 1")
    print(repr(header1[0:20000])) #repr() prints the info into neat columns
    print("HEADER 2")
    print(repr(header2[0:20000])) #repr() prints the info into neat columns
    print(fits.getdata(fits_file).columns)



#creating grid for the pixels and populating it with zeroes ( two 454x118 are the dimentions perfectly fit for the data, 1280x1024 was for testing)
PixelGrid = np.zeros((454,118), dtype=object)
#PixelGrid = np.zeros((1280,1024), dtype=object)

#creating variable for me to be able to download all my fits files they go from ktwo200004469 to ktwo200004923
x = 4469
#loop for me to read and retrieve information from each file
while x < 4923:
    fits_file = ("https://archive.stsci.edu/missions/k2/lightcurves/c3/200000000/04000/ktwo20000%d-c03_llc.fits" % x)
    with fits.open(fits_file) as hdulist: 
        header1 = hdulist[1].header
        header2 = hdulist[2].header
    with fits.open(fits_file, mode="readonly") as hdulist:
        #inserting data from each fits file into a variable
        tess_bjds = hdulist[1].data['TIME']
        sap_fluxes = hdulist[1].data['SAP_FLUX']
        pdcsap_fluxes = hdulist[1].data['PDCSAP_FLUX']
        RA = header2['Ra_OBJ']
        DEC = header2['DEC_OBJ']
        PosX = header2['CRVAL1P']
        PosY = header2['CRVAL2P']
 # Getting Coordinates from Dec/Asc into cartesian if needed
    Coord = SkyCoord((header2['Ra_OBJ'])*u.degree,(header2['DEC_OBJ'])*u.degree)     
    # creating a table with all the information that I gathered from the fits file into the data holder i created earlier, 
    #append will insert new rows into the data table with respective information
    #sap_fluxes[0] and tess_bjds[0] are the first instances(at time = 0) of flux and time, using until i find a way of getting the flux of all the time
    data.append([x,RA,DEC,PosX,PosY,sap_fluxes[0],tess_bjds[0]]) 
    #calculating realposX and realposY so i can create a appropriate sized grid since 
    #CCD positions go from Y 699 to 816(so i remove 699 to start and 0) same for posX(goes from 548 to 95)
    realPosX = (PosX-95)
    realPosY = (PosY-699)
    #realPosX = PosX #(test with 1280,1024 grid)
    #realPosY = PosY #(test with 1280,1024 grid)
    PixelGrid[realPosX, realPosY] = sap_fluxes[0] # inserting flux from time=0 (later make into all fluxes) into each respective X,Y positions
    x += 1 #for my while loop

#printing File number, RA, DEC, CCD X, CCD Y, flux, timestamp    
pixelDatatable = pd.DataFrame(data)
print (pixelDatatable)


# read in the array of cadence quality flags
with fits.open(fits_file, mode="readonly") as hdulist:
    qual_flags = hdulist[1].data['SAP_QUALITY']
# Start figure and axis.
fig, ax = plt.subplots()
# Plot the timeseries in black circles.
ax.plot(tess_bjds, pdcsap_fluxes, 'ko')
# Locate quality flags greater than zero.
where_gt0 = np.where(qual_flags > 0)[0]

'''# Overplot the fluxes with quality flags greater than zero in red.
ax.plot(tess_bjds[where_gt0], pdcsap_fluxes[where_gt0], 'ro')

fig.suptitle("Light Curve")
ax.set_ylabel("PDCSAP Flux (e-/s)")
ax.set_xlabel("Time (TBJD)")
plt.show()
'''

print('The matrix is : \n', PixelGrid) 
#imagePixelGrid = np.reshape(, (118,454))
imagePixelGrid = np.reshape(PixelGrid, (454,118))#not sure why i need to do this but i cant work with the grid unless i reshape it
#imagePixelGrid = PixelGrid#testing without reshaping

#creating image and saving image, astype() is used since the grid was an OBJECT grid and needed to be converted
ImageObj = Image.fromarray((PixelGrid).astype(np.uint8))
ImageObj.save('PixelGridTest.png')

#testing the pixel image show(not working)
im=plt.imshow(PixelGrid.astype(float), interpolation='nearest', cmap=cm.Greys_r)
plt.show()

#saving data into excel for further analysis
df = pd.DataFrame(PixelGrid).T
df.to_excel(excel_writer = "D:/Kepler Code/KeplerK2/gridexcel.xlsx")
df = pd.DataFrame(pixelDatatable).T
df.to_excel(excel_writer = "D:/Kepler Code/KeplerK2/gridexcelComplete.xlsx")